<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Encrypted Server Name Indication for TLS 1.3</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Conventions and Definitions">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Topologies">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 SNI Encryption">
<link href="#rfc.section.4" rel="Chapter" title="4 Encrypted SNI Configuration">
<link href="#rfc.section.5" rel="Chapter" title="5 The &#8220;encrypted_server_name&#8221; extension">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Client Behavior">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Sending an encrypted SNI">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Handling the server response">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Authenticating for the public name">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 GREASE extensions">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Client-Facing Server Behavior">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Shared Mode Server Behavior">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Split Mode Server Behavior">
<link href="#rfc.section.6" rel="Chapter" title="6 Compatibility Issues">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Misconfiguration and Deployment Concerns">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Middleboxes">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Why is cleartext DNS OK?">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Optional Record Digests and Trial Decryption">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Encrypting other Extensions">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Related Privacy Leaks">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Comparison Against Criteria">
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 Mitigate against replay attacks">
<link href="#rfc.section.7.5.2" rel="Chapter" title="7.5.2 Avoid widely-deployed shared secrets">
<link href="#rfc.section.7.5.3" rel="Chapter" title="7.5.3 Prevent SNI-based DoS attacks">
<link href="#rfc.section.7.5.4" rel="Chapter" title="7.5.4 Do not stick out">
<link href="#rfc.section.7.5.5" rel="Chapter" title="7.5.5 Forward secrecy">
<link href="#rfc.section.7.5.6" rel="Chapter" title="7.5.6 Proper security context">
<link href="#rfc.section.7.5.7" rel="Chapter" title="7.5.7 Split server spoofing">
<link href="#rfc.section.7.5.8" rel="Chapter" title="7.5.8 Supporting multiple protocols">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Misrouting">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Update of the TLS ExtensionType Registry">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Update of the TLS Alert Registry">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Update of the Resource Record (RR) TYPEs Registry">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Communicating SNI and Nonce to Backend Server">
<link href="#rfc.appendix.B" rel="Chapter" title="B Alternative SNI Protection Designs">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 TLS-layer">
<link href="#rfc.appendix.B.1.1" rel="Chapter" title="B.1.1 TLS in Early Data">
<link href="#rfc.appendix.B.1.2" rel="Chapter" title="B.1.2 Combined Tickets">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Application-layer">
<link href="#rfc.appendix.B.2.1" rel="Chapter" title="B.2.1 HTTP/2 CERTIFICATE Frames">
<link href="#rfc.appendix.C" rel="Chapter" title="C Total Client Hello Encryption">
<link href="#rfc.appendix.D" rel="Chapter" title="D Acknowledgements">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.34.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rescorla, E., Oku, K., Sullivan, N., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-tls-esni-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-11-04" />
  <meta name="dct.abstract" content="This document defines a simple mechanism for encrypting the Server Name Indication for TLS 1.3." />
  <meta name="description" content="This document defines a simple mechanism for encrypting the Server Name Indication for TLS 1.3." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">tls</td>
<td class="right">E. Rescorla</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">RTFM, Inc.</td>
</tr>
<tr>
<td class="left">Intended status: Experimental</td>
<td class="right">K. Oku</td>
</tr>
<tr>
<td class="left">Expires: May 7, 2020</td>
<td class="right">Fastly</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple, Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">November 04, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Encrypted Server Name Indication for TLS 1.3<br />
  <span class="filename">draft-ietf-tls-esni-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines a simple mechanism for encrypting the Server Name Indication for TLS 1.3.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 7, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Conventions and Definitions</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Topologies</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">SNI Encryption</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Encrypted SNI Configuration</a>
</li>
<li>5.   <a href="#rfc.section.5">The &#8220;encrypted_server_name&#8221; extension</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Client Behavior</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Sending an encrypted SNI</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Handling the server response</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Authenticating for the public name</a>
</li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">GREASE extensions</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Client-Facing Server Behavior</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Shared Mode Server Behavior</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Split Mode Server Behavior</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Compatibility Issues</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Misconfiguration and Deployment Concerns</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Middleboxes</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Why is cleartext DNS OK?</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Optional Record Digests and Trial Decryption</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Encrypting other Extensions</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Related Privacy Leaks</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Comparison Against Criteria</a>
</li>
<ul><li>7.5.1.   <a href="#rfc.section.7.5.1">Mitigate against replay attacks</a>
</li>
<li>7.5.2.   <a href="#rfc.section.7.5.2">Avoid widely-deployed shared secrets</a>
</li>
<li>7.5.3.   <a href="#rfc.section.7.5.3">Prevent SNI-based DoS attacks</a>
</li>
<li>7.5.4.   <a href="#rfc.section.7.5.4">Do not stick out</a>
</li>
<li>7.5.5.   <a href="#rfc.section.7.5.5">Forward secrecy</a>
</li>
<li>7.5.6.   <a href="#rfc.section.7.5.6">Proper security context</a>
</li>
<li>7.5.7.   <a href="#rfc.section.7.5.7">Split server spoofing</a>
</li>
<li>7.5.8.   <a href="#rfc.section.7.5.8">Supporting multiple protocols</a>
</li>
</ul><li>7.6.   <a href="#rfc.section.7.6">Misrouting</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Update of the TLS ExtensionType Registry</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Update of the TLS Alert Registry</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Update of the Resource Record (RR) TYPEs Registry</a>
</li>
</ul><li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Communicating SNI and Nonce to Backend Server</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Alternative SNI Protection Designs</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">TLS-layer</a>
</li>
<ul><li>B.1.1.   <a href="#rfc.appendix.B.1.1">TLS in Early Data</a>
</li>
<li>B.1.2.   <a href="#rfc.appendix.B.1.2">Combined Tickets</a>
</li>
</ul><li>B.2.   <a href="#rfc.appendix.B.2">Application-layer</a>
</li>
<ul><li>B.2.1.   <a href="#rfc.appendix.B.2.1">HTTP/2 CERTIFICATE Frames</a>
</li>
</ul></ul><li>Appendix C.   <a href="#rfc.appendix.C">Total Client Hello Encryption</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Acknowledgements</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is very early a work-in-progress design and has not yet seen significant (or really any) security analysis. It should not be used as a basis for building production systems.</p>
<p id="rfc.section.1.p.2">Although TLS 1.3 <a href="#RFC8446" class="xref">[RFC8446]</a> encrypts most of the handshake, including the server certificate, there are several other channels that allow an on-path attacker to determine the domain name the client is trying to connect to, including:</p>
<p></p>

<ul>
<li>Cleartext client DNS queries.</li>
<li>Visible server IP addresses, assuming the the server is not doing domain-based virtual hosting.</li>
<li>Cleartext Server Name Indication (SNI) <a href="#RFC6066" class="xref">[RFC6066]</a> in ClientHello messages.</li>
</ul>
<p id="rfc.section.1.p.4">DoH <a href="#I-D.ietf-doh-dns-over-https" class="xref">[I-D.ietf-doh-dns-over-https]</a> and DPRIVE <a href="#RFC7858" class="xref">[RFC7858]</a> <a href="#RFC8094" class="xref">[RFC8094]</a> provide mechanisms for clients to conceal DNS lookups from network inspection, and many TLS servers host multiple domains on the same IP address.  In such environments, SNI is an explicit signal used to determine the server&#8217;s identity. Indirect mechanisms such as traffic analysis also exist.</p>
<p id="rfc.section.1.p.5">The TLS WG has extensively studied the problem of protecting SNI, but has been unable to develop a completely generic solution. <a href="#I-D.ietf-tls-sni-encryption" class="xref">[I-D.ietf-tls-sni-encryption]</a> provides a description of the problem space and some of the proposed techniques. One of the more difficult problems is &#8220;Do not stick out&#8221; (<a href="#I-D.ietf-tls-sni-encryption" class="xref">[I-D.ietf-tls-sni-encryption]</a>; Section 3.4): if only sensitive/private services use SNI encryption, then SNI encryption is a signal that a client is going to such a service. For this reason, much recent work has focused on concealing the fact that SNI is being protected. Unfortunately, the result often has undesirable performance consequences, incomplete coverage, or both.</p>
<p id="rfc.section.1.p.6">The design in this document takes a different approach: it assumes that private origins will co-locate with or hide behind a provider (CDN, app server, etc.) which is able to activate encrypted SNI (ESNI) for all of the domains it hosts. Thus, the use of encrypted SNI does not indicate that the client is attempting to reach a private origin, but only that it is going to a particular service provider, which the observer could already tell from the IP address.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#conventions-and-definitions" id="conventions-and-definitions">Conventions and Definitions</a>
</h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here. All TLS notation comes from <a href="#RFC8446" class="xref">[RFC8446]</a>; Section 3.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.3.p.1">This document is designed to operate in one of two primary topologies shown below, which we call &#8220;Shared Mode&#8221; and &#8220;Split Mode&#8221;</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#topologies" id="topologies">Topologies</a>
</h1>
<div id="rfc.figure.1"></div>
<div id="shared-mode"></div>
<pre>
                +---------------------+
                |                     |
                |   2001:DB8::1111    |
                |                     |
Client &lt;-----&gt;  | private.example.org |
                |                     |
                | public.example.com  |
                |                     |
                +---------------------+
                        Server
</pre>
<p class="figure">Figure 1: Shared Mode Topology</p>
<p id="rfc.section.3.1.p.1">In Shared Mode, the provider is the origin server for all the domains whose DNS records point to it and clients form a TLS connection directly to that provider, which has access to the plaintext of the connection.</p>
<div id="rfc.figure.2"></div>
<div id="split-mode"></div>
<pre>
                +--------------------+       +---------------------+
                |                    |       |                     |
                |   2001:DB8::1111   |       |   2001:DB8::EEEE    |
Client &lt;------------------------------------&gt;|                     |
                | public.example.com |       | private.example.com |
                |                    |       |                     |
                +--------------------+       +---------------------+
                  Client-Facing Server            Backend Server
</pre>
<p class="figure">Figure 2: Split Mode Topology</p>
<p id="rfc.section.3.1.p.2">In Split Mode, the provider is <em>not</em> the origin server for private domains. Rather the DNS records for private domains point to the provider, and the provider&#8217;s server relays the connection back to the backend server, which is the true origin server. The provider does not have access to the plaintext of the connection.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#sni-encryption" id="sni-encryption">SNI Encryption</a>
</h1>
<p id="rfc.section.3.2.p.1">SNI encryption requires that each provider publish a public key and metadata which is used for SNI encryption for all the domains for which it serves directly or indirectly (via Split Mode). This document defines the format of the SNI encryption public key and metadata, referred to as an ESNI configuration, and delegates DNS publication details to <a href="#HTTPSSVC" class="xref">[HTTPSSVC]</a>, though other delivery mechanisms are possible. In particular, if some of the clients of a private server are applications rather than Web browsers, those applications might have the public key and metadata preconfigured.</p>
<p id="rfc.section.3.2.p.2">When a client wants to form a TLS connection to any of the domains served by an ESNI-supporting provider, it sends an &#8220;encrypted_server_name&#8221; extension, which contains the true extension encrypted under the provider&#8217;s public key. The provider can then decrypt the extension and either terminate the connection (in Shared Mode) or forward it to the backend server (in Split Mode).</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#esni-configuration" id="esni-configuration">Encrypted SNI Configuration</a>
</h1>
<p id="rfc.section.4.p.1">SNI Encryption configuration information is conveyed with the following ESNIConfig structure.</p>
<pre>
    // Copied from TLS 1.3
    struct {
        NamedGroup group;
        opaque key_exchange&lt;1..2^16-1&gt;;
    } KeyShareEntry;

    struct {
        uint16 version;
        opaque public_name&lt;1..2^16-1&gt;;
        KeyShareEntry keys&lt;4..2^16-1&gt;;
        CipherSuite cipher_suites&lt;2..2^16-2&gt;;
        uint16 padded_length;
        Extension extensions&lt;0..2^16-1&gt;;
    } ESNIConfig;
</pre>
<p id="rfc.section.4.p.2">The ESNIConfig structure contains the following fields:</p>
<p></p>

<dl>
<dt>version</dt>
<dd style="margin-left: 8">The version of the structure. For this specification, that value SHALL be 0xff03. Clients MUST ignore any ESNIConfig structure with a version they do not understand.  [[NOTE: This means that the RFC will presumably have a nonzero value.]]</dd>
<dt>public_name</dt>
<dd style="margin-left: 8">The non-empty name of the entity trusted to update these encryption keys.  This is used to repair misconfigurations, as described in <a href="#handle-server-response" class="xref">Section 5.1.2</a>.</dd>
<dt>keys</dt>
<dd style="margin-left: 8">The list of keys which can be used by the client to encrypt the SNI.  Every key being listed MUST belong to a different group.</dd>
</dl>
<p id="rfc.section.4.p.4">padded_length The length to pad the ServerNameList value to prior to encryption.  This value SHOULD be set to the largest ServerNameList the server expects to support rounded up the nearest multiple of 16. If the server supports arbitrary wildcard names, it SHOULD set this value to 260. Clients SHOULD reject ESNIConfig as invalid if padded_length is greater than 260.</p>
<p></p>

<dl>
<dt>extensions</dt>
<dd style="margin-left: 8">A list of extensions that the client can take into consideration when generating a Client Hello message. The format is defined in <a href="#RFC8446" class="xref">[RFC8446]</a>; Section 4.2. The purpose of the field is to provide room for additional features in the future. An extension may be tagged as mandatory by using an extension type codepoint with the high order bit set to 1. A client which receives a mandatory extension they do not understand must reject the ESNIConfig content.</dd>
</dl>
<p id="rfc.section.4.p.6">Any of the listed keys in the ESNIConfig value may be used to encrypt the SNI for the associated domain name.  The cipher suite list is orthogonal to the list of keys, so each key may be used with any cipher suite.  Clients MUST parse the extension list and check for unsupported mandatory extensions. If an unsupported mandatory extension is present, clients MUST reject the ESNIConfig value.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#esni-extension" id="esni-extension">The &#8220;encrypted_server_name&#8221; extension</a>
</h1>
<p id="rfc.section.5.p.1">The encrypted SNI is carried in an &#8220;encrypted_server_name&#8221; extension, defined as follows:</p>
<pre>
   enum {
       encrypted_server_name(0xffce), (65535)
   } ExtensionType;
</pre>
<p id="rfc.section.5.p.2">For clients (in ClientHello), this extension contains the following ClientEncryptedSNI structure:</p>
<pre>
   struct {
       CipherSuite suite;
       KeyShareEntry key_share;
       opaque record_digest&lt;0..2^16-1&gt;;
       opaque encrypted_sni&lt;0..2^16-1&gt;;
   } ClientEncryptedSNI;
</pre>
<p></p>

<dl>
<dt>suite</dt>
<dd style="margin-left: 8">The cipher suite used to encrypt the SNI.</dd>
<dt>key_share</dt>
<dd style="margin-left: 8">The KeyShareEntry carrying the client&#8217;s public ephemeral key share used to derive the ESNI key.</dd>
<dt>record_digest</dt>
<dd style="margin-left: 8">A cryptographic hash of the ESNIConfig structure from which the ESNI key was obtained, i.e., from the first byte of &#8220;version&#8221; to the end of the structure.  This hash is computed using the hash function associated with <samp>suite</samp>.</dd>
<dt>encrypted_sni</dt>
<dd style="margin-left: 8">The ClientESNIInner structure, AEAD-encrypted using cipher suite &#8220;suite&#8221; and the key generated as described below.</dd>
</dl>
<p id="rfc.section.5.p.4">For servers (in EncryptedExtensions), this extension contains the following structure:</p>
<pre>
   enum {
       esni_accept(0),
       esni_retry_request(1),
   } ServerESNIResponseType;

   struct {
       ServerESNIResponseType response_type;
       select (response_type) {
           case esni_accept:        uint8 nonce[16];
           case esni_retry_request: ESNIConfig retry_keys&lt;1..2^16-1&gt;;
       }
   } ServerEncryptedSNI;
</pre>
<p></p>

<dl>
<dt>response_type</dt>
<dd style="margin-left: 8">Indicates whether the server processed the client ESNI extension. (See <a href="#handle-server-response" class="xref">Section 5.1.2</a> and <a href="#server-behavior" class="xref">Section 5.2</a>.}</dd>
<dt>nonce</dt>
<dd style="margin-left: 8">The contents of ClientESNIInner.nonce. (See <a href="#client-behavior" class="xref">Section 5.1</a>.)</dd>
<dt>retry_keys</dt>
<dd style="margin-left: 8">One or more ESNIConfig structures containing the keys that the client should use on subsequent connections to encrypt the ClientESNIInner structure.</dd>
</dl>
<p id="rfc.section.5.p.6">This protocol also defines the &#8220;esni_required&#8221; alert, which is sent by the client when it offered an &#8220;encrypted_server_name&#8221; extension which was not accepted by the server.</p>
<pre>
   enum {
       esni_required(121),
   } AlertDescription;
</pre>
<p id="rfc.section.5.p.7">Finally, requirements in <a href="#client-behavior" class="xref">Section 5.1</a> and <a href="#server-behavior" class="xref">Section 5.2</a> require implementations to track, alongside each PSK established by a previous connection, whether the connection negotiated this extension with the &#8220;esni_accept&#8221; response type. If so, this is referred to as an &#8220;ESNI PSK&#8221;.  Otherwise, it is a &#8220;non-ESNI PSK&#8221;. This may be implemented by adding a new field to client and server session states.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#client-behavior" id="client-behavior">Client Behavior</a>
</h1>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#send-esni" id="send-esni">Sending an encrypted SNI</a>
</h1>
<p id="rfc.section.5.1.1.p.1">In order to send an encrypted SNI, the client MUST first select one of the server ESNIKeyShareEntry values and generate an (EC)DHE share in the matching group. This share will then be sent to the server in the &#8220;encrypted_server_name&#8221; extension and used to derive the SNI encryption key. It does not affect the (EC)DHE shared secret used in the TLS key schedule. The client MUST also select an appropriate cipher suite from the list of suites offered by the server. If the client is unable to select an appropriate group or suite it SHOULD ignore that ESNIConfig value and MAY attempt to use another value provided by the server. The client MUST NOT send encrypted SNI using groups or cipher suites not advertised by the server.</p>
<p id="rfc.section.5.1.1.p.2">When offering an encrypted SNI, the client MUST NOT offer to resume any non-ESNI PSKs. It additionally MUST NOT offer to resume any sessions for TLS 1.2 or below.</p>
<p id="rfc.section.5.1.1.p.3">Let Z be the DH shared secret derived from a key share in ESNIConfig and the corresponding client share in ClientEncryptedSNI.key_share. The SNI encryption key is computed from Z as follows:</p>
<pre>
   Zx = HKDF-Extract(0, Z)
   key = HKDF-Expand-Label(Zx, KeyLabel, Hash(ESNIContents), key_length)
   iv = HKDF-Expand-Label(Zx, IVLabel, Hash(ESNIContents), iv_length)
</pre>
<p id="rfc.section.5.1.1.p.4">where ESNIContents is as specified below and Hash is the hash function associated with the HKDF instantiation. The salt argument for HKDF-Extract is a string consisting of Hash.length bytes set to zeros. For a client&#8217;s first ClientHello, KeyLabel = &#8220;esni key&#8221; and IVLabel = &#8220;esni iv&#8221;, whereas for a client&#8217;s second ClientHello, sent in response to a HelloRetryRequest, KeyLabel = &#8220;hrr esni key&#8221; and IVLabel = &#8220;hrr esni iv&#8221;. (This label variance is done to prevent nonce re-use since the client&#8217;s ESNI key share, and thus the value of Zx, does not change across ClientHello retries.)</p>
<p id="rfc.section.5.1.1.p.5">Note that ESNIContents will not be directly transmitted to the server in the ClientHello. The server will instead reconstruct the same object by obtaining its values from ClientEncryptedSNI and ClientHello.</p>
<p id="rfc.section.5.1.1.p.6">[[TODO: label swapping fixes a bug in the spec, though this may not be the best way to deal with HRR. See https://github.com/tlswg/draft-ietf-tls-esni/issues/121 and https://github.com/tlswg/draft-ietf-tls-esni/pull/170 for more details.]]</p>
<pre>
   struct {
       opaque record_digest&lt;0..2^16-1&gt;;
       KeyShareEntry esni_key_share;
       Random client_hello_random;
   } ESNIContents;
</pre>
<p></p>

<dl>
<dt>record_digest</dt>
<dd style="margin-left: 8">Same value as ClientEncryptedSNI.record_digest.</dd>
<dt>esni_key_share</dt>
<dd style="margin-left: 8">Same value as ClientEncryptedSNI.key_share.</dd>
<dt>client_hello_random</dt>
<dd style="margin-left: 8">Same nonce as ClientHello.random.</dd>
</dl>
<p id="rfc.section.5.1.1.p.8">The client then creates a ClientESNIInner structure:</p>
<pre>
   struct {
       opaque dns_name&lt;1..2^16-1&gt;;
       opaque zeros[ESNIConfig.padded_length - length(dns_name)];
   } PaddedServerNameList;

   struct {
       uint8 nonce[16];
       PaddedServerNameList realSNI;
   } ClientESNIInner;
</pre>
<p></p>

<dl>
<dt>nonce</dt>
<dd style="margin-left: 8">A random 16-octet value to be echoed by the server in the &#8220;encrypted_server_name&#8221; extension.</dd>
<dt>dns_name</dt>
<dd style="margin-left: 8">The true SNI DNS name, that is, the HostName value that would have been sent in the plaintext &#8220;server_name&#8221; extension. (NameType values other than &#8220;host_name&#8221; are unsupported since SNI extensibility failed <a href="#SNIExtensibilityFailed" class="xref">[SNIExtensibilityFailed]</a>).</dd>
<dt>zeros</dt>
<dd style="margin-left: 8">Zero padding whose length makes the serialized PaddedServerNameList struct have a length equal to ESNIConfig.padded_length.</dd>
</dl>
<p id="rfc.section.5.1.1.p.10">This value consists of the serialized ServerNameList from the &#8220;server_name&#8221; extension, padded with enough zeroes to make the total structure ESNIConfig.padded_length bytes long. The purpose of the padding is to prevent attackers from using the length of the &#8220;encrypted_server_name&#8221; extension to determine the true SNI. If the serialized ServerNameList is longer than ESNIConfig.padded_length, the client MUST NOT use the &#8220;encrypted_server_name&#8221; extension.</p>
<p id="rfc.section.5.1.1.p.11">The ClientEncryptedSNI.encrypted_sni value is then computed using AEAD-Encrypt (<a href="#RFC5116" class="xref">[RFC5116]</a>; Section 2.1) with the AEAD corresponding to ClientEncryptedSNI.suite as follows:</p>
<pre>
    encrypted_sni = AEAD-Encrypt(key, iv, KeyShareClientHello, ClientESNIInner)
</pre>
<p id="rfc.section.5.1.1.p.12">Where KeyShareClientHello is the &#8220;extension_data&#8221; field of the &#8220;key_share&#8221; extension in a Client Hello (Section 4.2.8 of <a href="#RFC8446" class="xref">[RFC8446]</a>)). Including KeyShareClientHello in the AAD of AEAD-Encrypt binds the ClientEncryptedSNI value to the ClientHello and prevents cut-and-paste attacks.</p>
<p id="rfc.section.5.1.1.p.13">Note: future extensions may end up reusing the server&#8217;s ESNIKeyShareEntry for other purposes within the same message (e.g., encrypting other values). Those usages MUST have their own HKDF labels to avoid reuse.</p>
<p id="rfc.section.5.1.1.p.14">[[OPEN ISSUE: If in the future you were to reuse these keys for 0-RTT priming, then you would have to worry about potentially expanding twice of Z_extracted. We should think about how to harmonize these to make sure that we maintain key separation.]]</p>
<p id="rfc.section.5.1.1.p.15">This value is placed in an &#8220;encrypted_server_name&#8221; extension.</p>
<p id="rfc.section.5.1.1.p.16">The client MUST place the value of ESNIConfig.public_name in the &#8220;server_name&#8221; extension. (This is required for technical conformance with <a href="#RFC7540" class="xref">[RFC7540]</a>; Section 9.2.) The client MUST NOT send a &#8220;cached_info&#8221; extension <a href="#RFC7924" class="xref">[RFC7924]</a> with a CachedObject entry whose CachedInformationType is &#8220;cert&#8221;, since this indication would divulge the true server name.</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#handle-server-response" id="handle-server-response">Handling the server response</a>
</h1>
<p id="rfc.section.5.1.2.p.1">If the server negotiates TLS 1.3 or above and provides an &#8220;encrypted_server_name&#8221; extension in EncryptedExtensions, the client then processes the extension&#8217;s &#8220;response_type&#8221; field:</p>
<p></p>

<ul>
<li>If the value is &#8220;esni_accept&#8221;, the client MUST check that the extension&#8217;s &#8220;nonce&#8221; field matches ClientESNIInner.nonce and otherwise abort the connection with an &#8220;illegal_parameter&#8221; alert. The client then proceeds with the connection as usual, authenticating the connection for the origin server.</li>
<li>If the value is &#8220;esni_retry_request&#8221;, the client proceeds with the handshake, authenticating for ESNIConfig.public_name as described in <a href="#auth-public-name" class="xref">Section 5.1.3</a>. If authentication or the handshake fails, the client MUST return a failure to the calling application. It MUST NOT use the retry keys.  <br><br> Otherwise, when the handshake completes successfully with the public name authenticated, the client MUST abort the connection with an &#8220;esni_required&#8221; alert. It then processes the &#8220;retry_keys&#8221; field from the server&#8217;s &#8220;encrypted_server_name&#8221; extension.  <br><br> If one of the values contains a version supported by the client, it can regard the ESNI keys as securely replaced by the server. It SHOULD retry the handshake with a new transport connection, using that value to encrypt the SNI. The value may only be applied to the retry connection. The client MUST continue to use the previously-advertised keys for subsequent connections. This avoids introducing pinning concerns or a tracking vector, should a malicious server present client-specific retry keys to identify clients.  <br><br> If none of the values provided in &#8220;retry_keys&#8221; contains a supported version, the client can regard ESNI as securely disabled by the server. As below, it SHOULD then retry the handshake with a new transport connection and ESNI disabled.</li>
<li>If the field contains any other value, the client MUST abort the connection with an &#8220;illegal_parameter&#8221; alert.</li>
</ul>
<p id="rfc.section.5.1.2.p.3">If the server negotiates an earlier version of TLS, or if it does not provide an &#8220;encrypted_server_name&#8221; extension in EncryptedExtensions, the client proceeds with the handshake, authenticating for ESNIConfig.public_name as described in <a href="#auth-public-name" class="xref">Section 5.1.3</a>. If an earlier version was negotiated, the client MUST NOT enable the False Start optimization <a href="#RFC7918" class="xref">[RFC7918]</a> for this handshake. If authentication or the handshake fails, the client MUST return a failure to the calling application. It MUST NOT treat this as a secure signal to disable ESNI.</p>
<p id="rfc.section.5.1.2.p.4">Otherwise, when the handshake completes successfully with the public name authenticated, the client MUST abort the connection with an &#8220;esni_required&#8221; alert. The client can then regard ESNI as securely disabled by the server. It SHOULD retry the handshake with a new transport connection and ESNI disabled.</p>
<p id="rfc.section.5.1.2.p.5">[[TODO: Key replacement is significantly less scary than saying that ESNI-naive servers bounce ESNI off. Is it worth defining a strict mode toggle in the ESNI keys, for a deployment to indicate it is ready for that? ]]</p>
<p id="rfc.section.5.1.2.p.6">Clients SHOULD implement a limit on retries caused by &#8220;esni_retry_request&#8221; or servers which do not acknowledge the &#8220;encrypted_server_name&#8221; extension. If the client does not retry in either scenario, it MUST report an error to the calling application.</p>
<p id="rfc.section.5.1.2.p.7">If the server sends a HelloRetryRequest in response to the ClientHello and the client can send a second updated ClientHello per the rules in <a href="#RFC8446" class="xref">[RFC8446]</a>, the &#8220;encrypted_server_name&#8221; extension values which do not depend on the (possibly updated) KeyShareClientHello, i.e,, ClientEncryptedSNI.suite, ClientEncryptedSNI.key_share, and ClientEncryptedSNI.record_digest, MUST NOT change across ClientHello messages.  Moreover, ClientESNIInner MUST not change across ClientHello messages.  Informally, the values of all unencrypted extension information, as well as the inner extension plaintext, must be consistent between the first and second ClientHello messages.</p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#auth-public-name" id="auth-public-name">Authenticating for the public name</a>
</h1>
<p id="rfc.section.5.1.3.p.1">When the server cannot decrypt or does not process the &#8220;encrypted_server_name&#8221; extension, it continues with the handshake using the cleartext &#8220;server_name&#8221; extension instead (see <a href="#server-behavior" class="xref">Section 5.2</a>). Clients that offer ESNI then authenticate the connection with the public name, as follows:</p>
<p></p>

<ul>
<li>If the server resumed a session or negotiated a session that did not use a certificate for authentication, the client MUST abort the connection with an &#8220;illegal_parameter&#8221; alert. This case is invalid because <a href="#send-esni" class="xref">Section 5.1.1</a> requires the client to only offer ESNI-established sessions, and <a href="#server-behavior" class="xref">Section 5.2</a> requires the server to decline ESNI-established sessions if it did not accept ESNI.</li>
<li>The client MUST verify that the certificate is valid for ESNIConfig.public_name.  If invalid, it MUST abort the connection with the appropriate alert.</li>
<li>If the server requests a client certificate, the client MUST respond with an empty Certificate message, denoting no client certificate.</li>
</ul>
<p id="rfc.section.5.1.3.p.3">Note that authenticating a connection for the public name does not authenticate it for the origin. The TLS implementation MUST NOT report such connections as successful to the application. It additionally MUST ignore all session tickets and session IDs presented by the server. These connections are only used to trigger retries, as described in <a href="#handle-server-response" class="xref">Section 5.1.2</a>. This may be implemented, for instance, by reporting a failed connection with a dedicated error code.</p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#grease-extensions" id="grease-extensions">GREASE extensions</a>
</h1>
<p id="rfc.section.5.1.4.p.1">If the client attempts to connect to a server and does not have an ESNIConfig structure available for the server, it SHOULD send a GREASE <a href="#I-D.ietf-tls-grease" class="xref">[I-D.ietf-tls-grease]</a> &#8220;encrypted_server_name&#8221; extension as follows:</p>
<p></p>

<ul>
<li>Select a supported cipher suite, named group, and padded_length value. The padded_length value SHOULD be 260 (sum of the maximum DNS name length and TLS encoding overhead) or a multiple of 16 less than 260.  Set the &#8220;suite&#8221; field  to the selected cipher suite. These selections SHOULD vary to exercise all supported configurations, but MAY be held constant for successive connections to the same server in the same session.</li>
<li>Set the &#8220;key_share&#8221; field to a randomly-generated valid public key for the named group.</li>
<li>Set the &#8220;record_digest&#8221; field to a randomly-generated string of hash_length bytes, where hash_length is the length of the hash function associated with the chosen cipher suite.</li>
<li>Set the &#8220;encrypted_sni&#8221; field to a randomly-generated string of 16 + padded_length + tag_length bytes, where tag_length is the tag length of the chosen cipher suite&#8217;s associated AEAD.</li>
</ul>
<p id="rfc.section.5.1.4.p.3">If the server sends an &#8220;encrypted_server_name&#8221; extension, the client MUST check the extension syntactically and abort the connection with a &#8220;decode_error&#8221; alert if it is invalid. If the &#8220;response_type&#8221; field contains &#8220;esni_retry_requested&#8221;, the client MUST ignore the extension and proceed with the handshake. If it contains &#8220;esni_accept&#8221; or any other value, the client MUST abort the connection with an &#8220;illegal_parameter&#8221; alert.</p>
<p id="rfc.section.5.1.4.p.4">Offering a GREASE extension is not considered offering an encrypted SNI for purposes of requirements in <a href="#client-behavior" class="xref">Section 5.1</a>. In particular, the client MAY offer to resume sessions established without ESNI.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#server-behavior" id="server-behavior">Client-Facing Server Behavior</a>
</h1>
<p id="rfc.section.5.2.p.1">Upon receiving an &#8220;encrypted_server_name&#8221; extension, the client-facing server MUST check that it is able to negotiate TLS 1.3 or greater. If not, it MUST abort the connection with a &#8220;handshake_failure&#8221; alert.</p>
<p id="rfc.section.5.2.p.2">The ClientEncryptedSNI value is said to match a known ESNIConfig if there exists an ESNIConfig that can be used to successfully decrypt ClientEncryptedSNI.encrypted_sni.  This matching procedure should be done using one of the following two checks:</p>
<p></p>

<ol>
<li>Compare ClientEncryptedSNI.record_digest against cryptographic hashes of known ESNIConfig and choose the one that matches.</li>
<li>Use trial decryption of ClientEncryptedSNI.encrypted_sni with known ESNIConfig and choose the one that succeeds.</li>
</ol>
<p id="rfc.section.5.2.p.4">Some uses of ESNI, such as local discovery mode, may omit the ClientEncryptedSNI.record_digest since it can be used as a tracking vector. In such cases, trial decryption should be used for matching ClientEncryptedSNI to known ESNIConfig. Unless specified by the application using (D)TLS or externally configured on both sides, implementations MUST use the first method.</p>
<p id="rfc.section.5.2.p.5">If the ClientEncryptedSNI value does not match any known ESNIConfig structure, it MUST ignore the extension and proceed with the connection, with the following added behavior:</p>
<p></p>

<ul>
<li>It MUST include the &#8220;encrypted_server_name&#8221; extension in EncryptedExtensions message with the &#8220;response_type&#8221; field set to &#8220;esni_retry_requested&#8221; and the &#8220;retry_keys&#8221; field set to one or more ESNIConfig structures with up-to-date keys. Servers MAY supply multiple ESNIConfig values of different versions. This allows a server to support multiple versions at once.</li>
<li>The server MUST ignore all PSK identities in the ClientHello which correspond to ESNI PSKs. ESNI PSKs offered by the client are associated with the ESNI name. The server was unable to decrypt then ESNI name, so it should not resume them when using the cleartext SNI name. This restriction allows a client to reject resumptions in <a href="#auth-public-name" class="xref">Section 5.1.3</a>.</li>
</ul>
<p id="rfc.section.5.2.p.7">Note that an unrecognized ClientEncryptedSNI.record_digest value may be a GREASE ESNI extension (see <a href="#grease-extensions" class="xref">Section 5.1.4</a>), so it is necessary for servers to proceed with the connection and rely on the client to abort if ESNI was required. In particular, the unrecognized value alone does not indicate a misconfigured ESNI advertisement (<a href="#misconfiguration" class="xref">Section 6.1</a>). Instead, servers can measure occurrences of the &#8220;esni_required&#8221; alert to detect this case.</p>
<p id="rfc.section.5.2.p.8">If the ClientEncryptedSNI value does match a known ESNIConfig, the server performs the following checks:</p>
<p></p>

<ul>
<li>If the ClientEncryptedSNI.key_share group does not match one in the ESNIConfig.keys, it MUST abort the connection with an &#8220;illegal_parameter&#8221; alert.</li>
<li>If the length of the &#8220;encrypted_server_name&#8221; extension is inconsistent with the advertised padding length (plus AEAD expansion) the server MAY abort the connection with an &#8220;illegal_parameter&#8221; alert without attempting to decrypt.</li>
</ul>
<p id="rfc.section.5.2.p.10">Assuming these checks succeed, the server then computes K_sni and decrypts the ServerName value. If decryption fails, the server MUST abort the connection with a &#8220;decrypt_error&#8221; alert.</p>
<p id="rfc.section.5.2.p.11">If the decrypted value&#8217;s length is different from the advertised ESNIConfig.padded_length or the padding consists of any value other than 0, then the server MUST abort the connection with an &#8220;illegal_parameter&#8221; alert. Otherwise, the server uses the PaddedServerNameList.sni value as if it were the &#8220;server_name&#8221; extension. Any actual &#8220;server_name&#8221; extension is ignored, which also means the server MUST NOT send the &#8220;server_name&#8221; extension to the client.</p>
<p id="rfc.section.5.2.p.12">Upon determining the true SNI, the client-facing server then either serves the connection directly (if in Shared Mode), in which case it executes the steps in the following section, or forwards the TLS connection to the backend server (if in Split Mode). In the latter case, it does not make any changes to the TLS messages, but just blindly forwards them.</p>
<p id="rfc.section.5.2.p.13">If the ClientHello is the result of a HelloRetryRequest, servers MUST abort the connection with an &#8220;illegal_parameter&#8221; alert if any of the ClientEncryptedSNI.suite, ClientEncryptedSNI.key_share, ClientEncryptedSNI.record_digest, or decrypted ClientESNIInner values from the second ClientHello do not match that of the first ClientHello.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#shared-mode-server-behavior" id="shared-mode-server-behavior">Shared Mode Server Behavior</a>
</h1>
<p id="rfc.section.5.3.p.1">A server operating in Shared Mode uses PaddedServerNameList.sni as if it were the &#8220;server_name&#8221; extension to finish the handshake. It SHOULD pad the Certificate message, via padding at the record layer, such that its length equals the size of the largest possible Certificate (message) covered by the same ESNI key. Moreover, the server MUST include the &#8220;encrypted_server_name&#8221; extension in EncryptedExtensions with the &#8220;response_type&#8221; field set to &#8220;esni_accept&#8221; and the &#8220;nonce&#8221; field set to the decrypted PaddedServerNameList.nonce value from the client &#8220;encrypted_server_name&#8221; extension.</p>
<p id="rfc.section.5.3.p.2">If the server sends a NewSessionTicket message, the corresponding ESNI PSK MUST be ignored by all other servers in the deployment when not negotiating ESNI, including servers which do not implement this specification.</p>
<p id="rfc.section.5.3.p.3">This restriction provides robustness for rollbacks (see <a href="#misconfiguration" class="xref">Section 6.1</a>).</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#backend-server-behavior" id="backend-server-behavior">Split Mode Server Behavior</a>
</h1>
<p id="rfc.section.5.4.p.1">In Split Mode, the backend server must know PaddedServerNameList.nonce to echo it back in EncryptedExtensions and complete the handshake.  <a href="#communicating-sni" class="xref">Appendix A</a> describes one mechanism for sending both PaddedServerNameList.sni and ClientESNIInner.nonce to the backend server. Thus, backend servers function the same as servers operating in Shared Mode.</p>
<p id="rfc.section.5.4.p.2">As in Shared Mode, if the backend server sends a NewSessionTicket message, the corresponding ESNI PSK MUST be ignored by other servers in the deployment when not negotiating ESNI, including servers which do not implement this specification.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#compatibility-issues" id="compatibility-issues">Compatibility Issues</a>
</h1>
<p id="rfc.section.6.p.1">Unlike most TLS extensions, placing the SNI value in an ESNI extension is not interoperable with existing servers, which expect the value in the existing cleartext extension. Thus server operators SHOULD ensure servers understand a given set of ESNI keys before advertising them.  Additionally, servers SHOULD retain support for any previously-advertised keys for the duration of their validity.</p>
<p id="rfc.section.6.p.2">However, in more complex deployment scenarios, this may be difficult to fully guarantee. Thus this protocol was designed to be robust in case of inconsistencies between systems that advertise ESNI keys and servers, at the cost of extra round-trips due to a retry. Two specific scenarios are detailed below.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#misconfiguration" id="misconfiguration">Misconfiguration and Deployment Concerns</a>
</h1>
<p id="rfc.section.6.1.p.1">It is possible for ESNI advertisements and servers to become inconsistent. This may occur, for instance, from DNS misconfiguration, caching issues, or an incomplete rollout in a multi-server deployment. This may also occur if a server loses its ESNI keys, or if a deployment of ESNI must be rolled back on the server.</p>
<p id="rfc.section.6.1.p.2">The retry mechanism repairs inconsistencies, provided the server is authoritative for the public name. If server and advertised keys mismatch, the server will respond with esni_retry_requested. If the server does not understand the &#8220;encrypted_server_name&#8221; extension at all, it will ignore it as required by <a href="#RFC8446" class="xref">[RFC8446]</a>; Section 4.1.2. Provided the server can present a certificate valid for the public name, the client can safely retry with updated settings, as described in <a href="#handle-server-response" class="xref">Section 5.1.2</a>.</p>
<p id="rfc.section.6.1.p.3">Unless ESNI is disabled as a result of successfully establishing a connection to the public name, the client MUST NOT fall back to cleartext SNI, as this allows a network attacker to disclose the SNI.  It MAY attempt to use another server from the DNS results, if one is provided.</p>
<p id="rfc.section.6.1.p.4">Client-facing servers with non-uniform cryptographic configurations across backend origin servers segment the ESNI anonymity set based on these configurations. For example, if a client-facing server hosts k backend origin servers, and exactly one of those backend origin servers supports a different set of cryptographic algorithms than the other (k - 1) servers, it may be possible to identify this single server based on what negotiated (cleartext) algorithms.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#middleboxes" id="middleboxes">Middleboxes</a>
</h1>
<p id="rfc.section.6.2.p.1">A more serious problem is MITM proxies which do not support this extension. <a href="#RFC8446" class="xref">[RFC8446]</a>; Section 9.3 requires that such proxies remove any extensions they do not understand. The handshake will then present a certificate based on the public name, without echoing the &#8220;encrypted_server_name&#8221; extension to the client.</p>
<p id="rfc.section.6.2.p.2">Depending on whether the client is configured to accept the proxy&#8217;s certificate as authoritative for the public name, this may trigger the retry logic described in <a href="#handle-server-response" class="xref">Section 5.1.2</a> or result in a connection failure. A proxy which is not authoritative for the public name cannot forge a signal to disable ESNI.</p>
<p id="rfc.section.6.2.p.3">A non-conformant MITM proxy which instead forwards the ESNI extension, substituting its own KeyShare value, will result in the client-facing server recognizing the key, but failing to decrypt the SNI. This causes a hard failure. Clients SHOULD NOT attempt to repair the connection in this case.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#cleartext-dns" id="cleartext-dns">Why is cleartext DNS OK?</a>
</h1>
<p id="rfc.section.7.1.p.1">In comparison to <a href="#I-D.kazuho-protected-sni" class="xref">[I-D.kazuho-protected-sni]</a>, wherein DNS Resource Records are signed via a server private key, ESNI records have no authenticity or provenance information. This means that any attacker which can inject DNS responses or poison DNS caches, which is a common scenario in client access networks, can supply clients with fake ESNI records (so that the client encrypts SNI to them) or strip the ESNI record from the response. However, in the face of an attacker that controls DNS, no SNI encryption scheme can work because the attacker can replace the IP address, thus blocking client connections, or substituting a unique IP address which is 1:1 with the DNS name that was looked up (modulo DNS wildcards). Thus, allowing the ESNI records in the clear does not make the situation significantly worse.</p>
<p id="rfc.section.7.1.p.2">Clearly, DNSSEC (if the client validates and hard fails) is a defense against this form of attack, but DoH/DPRIVE are also defenses against DNS attacks by attackers on the local network, which is a common case where SNI is desired.  Moreover, as noted in the introduction, SNI encryption is less useful without encryption of DNS queries in transit via DoH or DPRIVE mechanisms.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#optional-record-digests-and-trial-decryption" id="optional-record-digests-and-trial-decryption">Optional Record Digests and Trial Decryption</a>
</h1>
<p id="rfc.section.7.2.p.1">Supporting optional record digests and trial decryption opens oneself up to DoS attacks. Specifically, an adversary may send malicious ClientHello messages, i.e., those which will not decrypt with any known ESNI key, in order to force decryption. Servers that support this feature should, for example, implement some form of rate limiting mechanism to limit the damage caused by such attacks.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#encrypting-other-extensions" id="encrypting-other-extensions">Encrypting other Extensions</a>
</h1>
<p id="rfc.section.7.3.p.1">ESNI protects only the SNI in transit. Other ClientHello extensions, such as ALPN, might also reveal privacy-sensitive information to the network. As such, it might be desirable to encrypt other extensions alongside the SNI. However, the SNI extension is unique in that non-TLS-terminating servers or load balancers may act on its contents.  Thus, using keys specifically for SNI encryption promotes key separation between client-facing servers and endpoints party to TLS connections.  Moreover, the ESNI design described herein does not preclude a mechanism for generic ClientHello extension encryption.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#related-privacy-leaks" id="related-privacy-leaks">Related Privacy Leaks</a>
</h1>
<p id="rfc.section.7.4.p.1">ESNI requires encrypted DNS to be an effective privacy protection mechanism.  However, verifying the server&#8217;s identity from the Certificate message, particularly when using the X509 CertificateType, may result in additional network traffic that may reveal the server identity. Examples of this traffic may include requests for revocation information, such as OCSP or CRL traffic, or requests for repository information, such as authorityInformationAccess. It may also include implementation-specific traffic for additional information sources as part of verification.</p>
<p id="rfc.section.7.4.p.2">Implementations SHOULD avoid leaking information that may identify the server. Even when sent over an encrypted transport, such requests may result in indirect exposure of the server&#8217;s identity, such as indicating a specific CA or service being used. To mitigate this risk, servers SHOULD deliver such information in-band when possible, such as through the use of OCSP stapling, and clients SHOULD take steps to minimize or protect such requests during certificate validation.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#comparison-against-criteria" id="comparison-against-criteria">Comparison Against Criteria</a>
</h1>
<p><a href="#I-D.ietf-tls-sni-encryption" class="xref">[I-D.ietf-tls-sni-encryption]</a> lists several requirements for SNI encryption. In this section, we re-iterate these requirements and assess the ESNI design against them.</p>
<h1 id="rfc.section.7.5.1">
<a href="#rfc.section.7.5.1">7.5.1.</a> <a href="#mitigate-against-replay-attacks" id="mitigate-against-replay-attacks">Mitigate against replay attacks</a>
</h1>
<p id="rfc.section.7.5.1.p.1">Since the SNI encryption key is derived from a (EC)DH operation between the client&#8217;s ephemeral and server&#8217;s semi-static ESNI key, the ESNI encryption is bound to the Client Hello. It is not possible for an attacker to &#8220;cut and paste&#8221; the ESNI value in a different Client Hello, with a different ephemeral key share, as the terminating server will fail to decrypt and verify the ESNI value.</p>
<h1 id="rfc.section.7.5.2">
<a href="#rfc.section.7.5.2">7.5.2.</a> <a href="#avoid-widely-deployed-shared-secrets" id="avoid-widely-deployed-shared-secrets">Avoid widely-deployed shared secrets</a>
</h1>
<p id="rfc.section.7.5.2.p.1">This design depends upon DNS as a vehicle for semi-static public key distribution.  Server operators may partition their private keys however they see fit provided each server behind an IP address has the corresponding private key to decrypt a key. Thus, when one ESNI key is provided, sharing is optimally bound by the number of hosts that share an IP address. Server operators may further limit sharing by publishing different DNS records containing ESNIConfig values with different keys using a short TTL.</p>
<h1 id="rfc.section.7.5.3">
<a href="#rfc.section.7.5.3">7.5.3.</a> <a href="#prevent-sni-based-dos-attacks" id="prevent-sni-based-dos-attacks">Prevent SNI-based DoS attacks</a>
</h1>
<p id="rfc.section.7.5.3.p.1">This design requires servers to decrypt ClientHello messages with ClientEncryptedSNI extensions carrying valid digests. Thus, it is possible for an attacker to force decryption operations on the server. This attack is bound by the number of valid TCP connections an attacker can open.</p>
<h1 id="rfc.section.7.5.4">
<a href="#rfc.section.7.5.4">7.5.4.</a> <a href="#do-not-stick-out" id="do-not-stick-out">Do not stick out</a>
</h1>
<p id="rfc.section.7.5.4.p.1">As more clients enable ESNI support, e.g., as normal part of Web browser functionality, with keys supplied by shared hosting providers, the presence of ESNI extensions becomes less suspicious and part of common or predictable client behavior. In other words, if all Web browsers start using ESNI, the presence of this value does not signal suspicious behavior to passive eavesdroppers.</p>
<p id="rfc.section.7.5.4.p.2">Additionally, this specification allows for clients to send GREASE ESNI extensions (see <a href="#grease-extensions" class="xref">Section 5.1.4</a>), which helps ensure the ecosystem handles the values correctly.</p>
<h1 id="rfc.section.7.5.5">
<a href="#rfc.section.7.5.5">7.5.5.</a> <a href="#forward-secrecy" id="forward-secrecy">Forward secrecy</a>
</h1>
<p id="rfc.section.7.5.5.p.1">This design is not forward secret because the server&#8217;s ESNI key is static.  However, the window of exposure is bound by the key lifetime. It is RECOMMENDED that servers rotate keys frequently.</p>
<h1 id="rfc.section.7.5.6">
<a href="#rfc.section.7.5.6">7.5.6.</a> <a href="#proper-security-context" id="proper-security-context">Proper security context</a>
</h1>
<p id="rfc.section.7.5.6.p.1">This design permits servers operating in Split Mode to forward connections directly to backend origin servers, thereby avoiding unnecessary MiTM attacks.</p>
<h1 id="rfc.section.7.5.7">
<a href="#rfc.section.7.5.7">7.5.7.</a> <a href="#split-server-spoofing" id="split-server-spoofing">Split server spoofing</a>
</h1>
<p id="rfc.section.7.5.7.p.1">Assuming ESNI records retrieved from DNS are authenticated, e.g., via DNSSEC or fetched from a trusted Recursive Resolver, spoofing a server operating in Split Mode is not possible. See <a href="#cleartext-dns" class="xref">Section 7.1</a> for more details regarding cleartext DNS.</p>
<p id="rfc.section.7.5.7.p.2">Authenticating the ESNIConfig structure naturally authenticates the included public name. This also authenticates any retry signals from the server because the client validates the server certificate against the public name before retrying.</p>
<h1 id="rfc.section.7.5.8">
<a href="#rfc.section.7.5.8">7.5.8.</a> <a href="#supporting-multiple-protocols" id="supporting-multiple-protocols">Supporting multiple protocols</a>
</h1>
<p id="rfc.section.7.5.8.p.1">This design has no impact on application layer protocol negotiation. It may affect connection routing, server certificate selection, and client certificate verification.  Thus, it is compatible with multiple protocols.</p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#misrouting" id="misrouting">Misrouting</a>
</h1>
<p id="rfc.section.7.6.p.1">Note that the backend server has no way of knowing what the SNI was, but that does not lead to additional privacy exposure because the backend server also only has one identity. This does, however, change the situation slightly in that the backend server might previously have checked SNI and now cannot (and an attacker can route a connection with an encrypted SNI to any backend server and the TLS connection will still complete).  However, the client is still responsible for verifying the server&#8217;s identity in its certificate.</p>
<p id="rfc.section.7.6.p.2">[[TODO: Some more analysis needed in this case, as it is a little odd, and probably some precise rules about handling ESNI and no SNI uniformly?]]</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#update-of-the-tls-extensiontype-registry" id="update-of-the-tls-extensiontype-registry">Update of the TLS ExtensionType Registry</a>
</h1>
<p id="rfc.section.8.1.p.1">IANA is requested to create an entry, encrypted_server_name(0xffce), in the existing registry for ExtensionType (defined in <a href="#RFC8446" class="xref">[RFC8446]</a>), with &#8220;TLS 1.3&#8221; column values being set to &#8220;CH, EE&#8221;, and &#8220;Recommended&#8221; column being set to &#8220;Yes&#8221;.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#update-of-the-tls-alert-registry" id="update-of-the-tls-alert-registry">Update of the TLS Alert Registry</a>
</h1>
<p id="rfc.section.8.2.p.1">IANA is requested to create an entry, esni_required(121) in the existing registry for Alerts (defined in <a href="#RFC8446" class="xref">[RFC8446]</a>), with the &#8220;DTLS-OK&#8221; column being set to &#8220;Y&#8221;.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#update-of-the-resource-record-rr-types-registry" id="update-of-the-resource-record-rr-types-registry">Update of the Resource Record (RR) TYPEs Registry</a>
</h1>
<p id="rfc.section.8.3.p.1">IANA is requested to create an entry, ESNI(0xff9f), in the existing registry for Resource Record (RR) TYPEs (defined in <a href="#RFC6895" class="xref">[RFC6895]</a>) with &#8220;Meaning&#8221; column value being set to &#8220;Encrypted SNI&#8221;.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="HTTPSSVC">[HTTPSSVC]</b></td>
<td class="top">
<a>Schwartz, B.</a>, <a>Bishop, M.</a> and <a>E. Nygren</a>, "<a href="https://tools.ietf.org/html/draft-nygren-dnsop-svcb-httpssvc-00">Service binding and parameter specification via the DNS (DNS SVCB and HTTPSSVC)</a>", Internet-Draft draft-nygren-dnsop-svcb-httpssvc-00, September 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-exported-authenticator">[I-D.ietf-tls-exported-authenticator]</b></td>
<td class="top">
<a>Sullivan, N.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-exported-authenticator-09">Exported Authenticators in TLS</a>", Internet-Draft draft-ietf-tls-exported-authenticator-09, May 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1035">[RFC1035]</b></td>
<td class="top">
<a>Mockapetris, P.</a>, "<a href="https://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5116">[RFC5116]</b></td>
<td class="top">
<a>McGrew, D.</a>, "<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6066">[RFC6066]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6066">Transport Layer Security (TLS) Extensions: Extension Definitions</a>", RFC 6066, DOI 10.17487/RFC6066, January 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6234">[RFC6234]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a> and <a>T. Hansen</a>, "<a href="https://tools.ietf.org/html/rfc6234">US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</a>", RFC 6234, DOI 10.17487/RFC6234, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6895">[RFC6895]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, "<a href="https://tools.ietf.org/html/rfc6895">Domain Name System (DNS) IANA Considerations</a>", BCP 42, RFC 6895, DOI 10.17487/RFC6895, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7918">[RFC7918]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Modadugu, N.</a> and <a>B. Moeller</a>, "<a href="https://tools.ietf.org/html/rfc7918">Transport Layer Security (TLS) False Start</a>", RFC 7918, DOI 10.17487/RFC7918, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7924">[RFC7924]</b></td>
<td class="top">
<a>Santesson, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc7924">Transport Layer Security (TLS) Cached Information Extension</a>", RFC 7924, DOI 10.17487/RFC7924, July 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-doh-dns-over-https">[I-D.ietf-doh-dns-over-https]</b></td>
<td class="top">
<a>Hoffman, P.</a> and <a>P. McManus</a>, "<a href="https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-14">DNS Queries over HTTPS (DoH)</a>", Internet-Draft draft-ietf-doh-dns-over-https-14, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-grease">[I-D.ietf-tls-grease]</b></td>
<td class="top">
<a>Benjamin, D.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-grease-04">Applying GREASE to TLS Extensibility</a>", Internet-Draft draft-ietf-tls-grease-04, August 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-sni-encryption">[I-D.ietf-tls-sni-encryption]</b></td>
<td class="top">
<a>Huitema, C.</a> and <a>E. Rescorla</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-sni-encryption-09">Issues and Requirements for SNI Encryption in TLS</a>", Internet-Draft draft-ietf-tls-sni-encryption-09, October 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.kazuho-protected-sni">[I-D.kazuho-protected-sni]</b></td>
<td class="top">
<a>Oku, K.</a>, "<a href="https://tools.ietf.org/html/draft-kazuho-protected-sni-00">TLS Extensions for Protecting SNI</a>", Internet-Draft draft-kazuho-protected-sni-00, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7858">[RFC7858]</b></td>
<td class="top">
<a>Hu, Z.</a>, <a>Zhu, L.</a>, <a>Heidemann, J.</a>, <a>Mankin, A.</a>, <a>Wessels, D.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7858">Specification for DNS over Transport Layer Security (TLS)</a>", RFC 7858, DOI 10.17487/RFC7858, May 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8094">[RFC8094]</b></td>
<td class="top">
<a>Reddy, T.</a>, <a>Wing, D.</a> and <a>P. Patil</a>, "<a href="https://tools.ietf.org/html/rfc8094">DNS over Datagram Transport Layer Security (DTLS)</a>", RFC 8094, DOI 10.17487/RFC8094, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SNIExtensibilityFailed">[SNIExtensibilityFailed]</b></td>
<td class="top">"<a href="https://mailarchive.ietf.org/arch/msg/tls/1t79gzNItZd71DwwoaqcQQ_4Yxc">Accepting that other SNI name types will never work</a>", n.d..</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#communicating-sni" id="communicating-sni">Communicating SNI and Nonce to Backend Server</a>
</h1>
<p id="rfc.section.A.p.1">When operating in Split Mode, backend servers will not have access to PaddedServerNameList.sni or ClientESNIInner.nonce without access to the ESNI keys or a way to decrypt ClientEncryptedSNI.encrypted_sni.</p>
<p id="rfc.section.A.p.2">One way to address this for a single connection, at the cost of having communication not be unmodified TLS 1.3, is as follows.  Assume there is a shared (symmetric) key between the client-facing server and the backend server and use it to AEAD-encrypt Z and send the encrypted blob at the beginning of the connection before the ClientHello. The backend server can then decrypt ESNI to recover the true SNI and nonce.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#alternative-sni-protection-designs" id="alternative-sni-protection-designs">Alternative SNI Protection Designs</a>
</h1>
<p id="rfc.section.B.p.1">Alternative approaches to encrypted SNI may be implemented at the TLS or application layer. In this section we describe several alternatives and discuss drawbacks in comparison to the design in this document.</p>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#tls-layer" id="tls-layer">TLS-layer</a>
</h1>
<h1 id="rfc.appendix.B.1.1">
<a href="#rfc.appendix.B.1.1">B.1.1.</a> <a href="#tls-in-early-data" id="tls-in-early-data">TLS in Early Data</a>
</h1>
<p id="rfc.section.B.1.1.p.1">In this variant, TLS Client Hellos are tunneled within early data payloads belonging to outer TLS connections established with the client-facing server. This requires clients to have established a previous session -&#8212; and obtained PSKs &#8212;- with the server. The client-facing server decrypts early data payloads to uncover Client Hellos destined for the backend server, and forwards them onwards as necessary. Afterwards, all records to and from backend servers are forwarded by the client-facing server &#8211; unmodified.  This avoids double encryption of TLS records.</p>
<p id="rfc.section.B.1.1.p.2">Problems with this approach are: (1) servers may not always be able to distinguish inner Client Hellos from legitimate application data, (2) nested 0-RTT data may not function correctly, (3) 0-RTT data may not be supported &#8211; especially under DoS &#8211; leading to availability concerns, and (4) clients must bootstrap tunnels (sessions), costing an additional round trip and potentially revealing the SNI during the initial connection. In contrast, encrypted SNI protects the SNI in a distinct Client Hello extension and neither abuses early data nor requires a bootstrapping connection.</p>
<h1 id="rfc.appendix.B.1.2">
<a href="#rfc.appendix.B.1.2">B.1.2.</a> <a href="#combined-tickets" id="combined-tickets">Combined Tickets</a>
</h1>
<p id="rfc.section.B.1.2.p.1">In this variant, client-facing and backend servers coordinate to produce &#8220;combined tickets&#8221; that are consumable by both. Clients offer combined tickets to client-facing servers.  The latter parse them to determine the correct backend server to which the Client Hello should be forwarded. This approach is problematic due to non-trivial coordination between client-facing and backend servers for ticket construction and consumption. Moreover, it requires a bootstrapping step similar to that of the previous variant. In contrast, encrypted SNI requires no such coordination.</p>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#application-layer" id="application-layer">Application-layer</a>
</h1>
<h1 id="rfc.appendix.B.2.1">
<a href="#rfc.appendix.B.2.1">B.2.1.</a> <a href="#http2-certificate-frames" id="http2-certificate-frames">HTTP/2 CERTIFICATE Frames</a>
</h1>
<p id="rfc.section.B.2.1.p.1">In this variant, clients request secondary certificates with CERTIFICATE_REQUEST HTTP/2 frames after TLS connection completion. In response, servers supply certificates via TLS exported authenticators <a href="#I-D.ietf-tls-exported-authenticator" class="xref">[I-D.ietf-tls-exported-authenticator]</a> in CERTIFICATE frames.  Clients use a generic SNI for the underlying client-facing server TLS connection.  Problems with this approach include: (1) one additional round trip before peer authentication, (2) non-trivial application-layer dependencies and interaction, and (3) obtaining the generic SNI to bootstrap the connection. In contrast, encrypted SNI induces no additional round trip and operates below the application layer.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#total-client-hello-encryption" id="total-client-hello-encryption">Total Client Hello Encryption</a>
</h1>
<p id="rfc.section.C.p.1">The design described here only provides encryption for the SNI, but not for other extensions, such as ALPN. Another potential design would be to encrypt all of the extensions using the same basic structure as we use here for ESNI. That design has the following advantages:</p>
<p></p>

<ul>
<li>It protects all the extensions from ordinary eavesdroppers</li>
<li>If the encrypted block has its own KeyShare, it does not necessarily require the client to use a single KeyShare, because the client&#8217;s share is bound to the SNI by the AEAD (analysis needed).</li>
</ul>
<p id="rfc.section.C.p.3">It also has the following disadvantages:</p>
<p></p>

<ul>
<li>The client-facing server can still see the other extensions. By contrast we could introduce another EncryptedExtensions block that was encrypted to the backend server and not the client-facing server.</li>
<li>It requires a mechanism for the client-facing server to provide the extension-encryption key to the backend server (as in <a href="#communicating-sni" class="xref">Appendix A</a> and thus cannot be used with an unmodified backend server.</li>
<li>A conformant middlebox will strip every extension, which might result in a ClientHello which is just unacceptable to the server (more analysis needed).</li>
</ul>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.D.p.1">This document draws extensively from ideas in <a href="#I-D.kazuho-protected-sni" class="xref">[I-D.kazuho-protected-sni]</a>, but is a much more limited mechanism because it depends on the DNS for the protection of the ESNI key. Richard Barnes, Christian Huitema, Patrick McManus, Matthew Prince, Nick Sullivan, Martin Thomson, and David Benjamin also provided important ideas and contributions.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Kazuho Oku</span> 
	  <span class="n hidden">
		<span class="family-name">Oku</span>
	  </span>
	</span>
	<span class="org vcardline">Fastly</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:kazuhooku@gmail.com">kazuhooku@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>

